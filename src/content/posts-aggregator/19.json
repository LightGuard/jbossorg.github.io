{
  "title": "Tooling guide for Getting Started with Apache Camel in 2021",
  "link": "http://feedproxy.google.com/~r/blogspot/hFXzh/~3/N9sx2zTVps4/tooling-guide-for-getting-started-with.html",
  "author": [
    {
      "name": "CHRISTINA の J老闆",
      "avatar": null
    }
  ],
  "date": "2021-05-26T13:20:00.002Z",
  "feed_title": "Christina の J老闆",
  "content": "Getting Started with Apache Camel ? This post is for you. But I am not going to dive into how to write the Camel route, there are plenty of materials out there that do a better job than me. A good place to get started is the one and only , it gives you all the latest and greatest news from the community. If you want to start from the basics, I highly recommend Camel in Action II Book. It has everything you need to know about writing Camel. Or join the Camel community or chat  to ask questions, it's very friendly and welcoming.  If you are a returning Camel rider, I would go through this , where it will get you up to speed on what to expect.  Another good resource is the page. I found the majority of the getting started enquiries can be found here.    This post will be about tools that can help you, when it comes to running a Camel application in its lifetime. From design, implementation, testing, deployment and monitoring. Of course this is strictly my opinion. Any suggestions or comments are welcome.   Here is a quick collection of the tools I recommend.           DESIGN & IMPLEMENTATION   There are several different IDEs out there that have language support for Camel. My current goto is the . VS Code itself has very primitive support for Java developers, but it comes with a large variety of extensions for you to customize it, and install all the tools you need. Speaking of extension, there is a must have… “”. It contains the essentials for developing Camel. I recommend checking out the for updates!    To begin a project, it’s always good to have some help to set the basic structure. You can either use the Project Initializer that comes with the Apache Camel by Red Hat Extension in VS Code that will generate the base project for you. Or you can always go to the Quarkus start coding page, adding the Camel dependencies to create the base project, but one downside of the Quarkus start coding page, it will not create the template extended RouteBuilder class for you.    No matter what runtime you choose, you are still writing Camel DSL (Domain Specific Language), you have the latest and greatest support from the camel extension, where it will help you with autocomplete, validating your Camel code.              Mapping data between formats can be tedious, especially with larger documents or more complex structure. But using the     tooling can help you map between two data sources with a drag and drop user interface, so you will be able to visualize the mappings. The tool will generate an “.adm” file, place the file into your Camel project. You can then use the camel-atlasmap components to run the mapping.             from(\"servicenow:xxxxxx....\")    .split().body()      .marshal().json()      .to(\"atlasmap:servicenow.adm\")      .to(\"kafka:xxx?brokersxxx\")   RESTful API is another popular implementation in Camel, I highly recommend you take advantage of the Apicurio project, where it provides a GUI interface for designing the API contract. Making contract first application development a lot easier. For more details, take a look at my previous .                 Another nice complements to the toolset is the , this is another extension in VS Code by Bruno, this can help you visualize the design of camel processing flow. So you will be able to see what your camel route does in a quick glance.               TESTING      Camel can easily wire up unit tests in your preferred testing framework. My past experience has been great with using JUnit for creating my test cases.       What I normally would do is create a java Class for each test case (Extend “CamelTestSupport” class). Where it can kick off your camel route with mock endpoints, loading set of data or even stub out the actual endpoint   When testing integration, introducing Behavior-Driven Development(BDD) Testing is a development practice, as it’s black box testing nature allows it to better mimic user input and expectation, and can test more complex scenarios when compared to Test-Driven Development(TDD). Consider using the “” for building out BDD test cases. You can define the test scenario descriptions with a \"Given-When-Then\" structure in a feature file, as well as a simple setup for mimicking the common endpoints such as Kafka, AMQP, JMS, REST… etc.     Feature: integration runs       Background:      Given load variables namespace.properties      Given URL: http://camel-hello-quarkus.${namespace}.svc.cluster.local:8080       Scenario: Checking GET Method      When send GET /prescription?profileid=123456      Then verify HTTP response body: {\"profileid\": 123456, \"pharmancy\": \"CVS\" }      Then receive HTTP 200 OK    I have also been using a spinoff project from Citrus called YAKs to do my BDD testing on Kubernetes(OpenShift) platform. And I LOVED it. Simply because 1st, the lifecycle of the test was managed by the YAKs operator, meaning the test was run on a separate instance, that is where the client supposed the call, and also the YAKs operator takes in the feature, and does the test based on it. You can run it separately or plug it into your CI/CD pipeline.               PLATFORM  I have been using for managing all the running instances. It's just easier when there are hundreds of Camels running, it manages the scaling, resources, configuration and load-balancing for me. As well as a better deployment module (images). There are so many articles out there talking about the benefits of running a container & container management, so I won’t dive into it.     CI/CD  Jenkin was on my list for a long time when it comes to building the pipeline for my Camel application. Basically using the maven jenkins plugin for compiling and deploying, and using the OpenShift plugin to do the canary releases. And recently, I have been using the Tekton pipeline, it’s built-in on OpenShift, so there is no need to install a separate instance and manage it. The Kubernetes platform itself will become the CI/CD platform itself. Here is an example of how it works with the Camel projects. I will write another deep dive into how it works.                MONITORING  With Camel 3, in order to collect and export the metrics, you will need to specifically add the microprofile-metrics dependency. And by using Prometheus to scrape metrics on the platform. It stores all scraped samples locally and aggregate the time series data. I then use Grafana to visualize the collected data, and create a dashboard to monitor all the camel routes.        Also checkout this video and see how things work:          "
}